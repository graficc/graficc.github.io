[{"categories":[""],"content":"个人概况 大连理工大学19级软件工程学院本科生，大三在读。 目前主要的研究方向是计算机图形学（Computer Graphics）。 最喜爱的程序员是John Carmack和Linus Torvalds Which hurts more , the pain of hard work or the pain of regret ? ","date":"2022-04-22","objectID":"/about/:1:0","tags":[""],"title":"About","uri":"/about/"},{"categories":[""],"content":"个人项目 个人博客网站：https://horel.github.io/ GAMES101作业：https://github.com/horel/GAMES101/ ","date":"2022-04-22","objectID":"/about/:2:0","tags":[""],"title":"About","uri":"/about/"},{"categories":[""],"content":"友链 Horel 的 UnOfficial 博客：https://horel.github.io/ ","date":"2022-04-22","objectID":"/about/:3:0","tags":[""],"title":"About","uri":"/about/"},{"categories":["Programming Language"],"content":"常见的坑 auto可以在一条语句中声明多个变量，但是所有变量的类型必须一致。 decltype在分析表达式类型时并不执行表达式。 decltype处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。 decltype((variable))的结果永远是引用。 decltype(variable)的结果只有当variable是引用时才是引用。 ","date":"2021-10-26","objectID":"/posts/auto/:1:0","tags":["C++"],"title":"重学C++：类型推导","uri":"/posts/auto/"},{"categories":["Programming Language"],"content":"必须要理解的点 auto用于变量初始化时的类型推导，decltype用于分析表达式的类型。 auto对引用类型推导时实际上用的是引用对象的值。 auto与const：详见重学C++：Const二三事。 decltype与const：详见重学C++：Const二三事。 ","date":"2021-10-26","objectID":"/posts/auto/:2:0","tags":["C++"],"title":"重学C++：类型推导","uri":"/posts/auto/"},{"categories":["Programming Language"],"content":"建议 auto尽量只在类型较长但比较清晰时使用。 decltype尽量不要使用。 ","date":"2021-10-26","objectID":"/posts/auto/:3:0","tags":["C++"],"title":"重学C++：类型推导","uri":"/posts/auto/"},{"categories":["Programming Language"],"content":"常见的坑 仅用const修饰的对象只在单个文件中有效，如果想在多个文件之间共享const对象，必须在对象定义的前面加extern。 允许为一个常量引用绑定非常量的对象、字面量和表达式。 int i = 42; const int \u0026r1 = i; // 正确 const int \u0026r2 = 42; // 正确 const int \u0026r3 = r1 * 2; // 正确 int \u0026r4 = r1 * 2; // 错误 int \u0026r5 = i; r5 = 0; // 正确 r1 = 42; // 错误 指向常量的指针和常量指针： int err_numb = 0; const double pi = 3.1415; int *const cur_err = \u0026err_numb; const double *mut_pi_pointer = \u0026pi; const double *const pi_pointer = \u0026pi; 从声明语句的变量符号开始，自右向左看： cur_err首先是一个不可变对象，其次是一个指向int类型可变对象的指针。 mut_pi_pointer首先是一个可变对象，其次是一个指向double类型不可变对象的指针。 pi_pointer首先是一个不可变对象，其次是一个指向double类型不可变对象的指针。 当typedef遇到const时容易出现错误理解： typedef char *pstring; const pstring cstr = 0; const pstring *ps = 0; pstring是char *的别名，即指向char的指针。 const修饰的是pstring，因此cstr是：初始化值为nullptr的不可变指针。 错误理解会用char *替换掉pstring，即： const char *cstr = 0; 这样从cstr开始自右向左读的话，cstr就会被理解成：指向字符常量的可变指针。 constexpr属于顶层const，因此constexpr修饰指针意味着指针本身不可变。 auto默认会去除顶层const，保留底层const，如果需要顶层const则需要显式加入。 int i = 0; const int ci = i, \u0026cr = ci; auto b = ci; // b是一个初始化值为0的可变int对象 auto c = cr; // c同b auto d = \u0026i; // d是一个初始化为指向可变int类对象i的可变指针对象 auto e = \u0026ci; // e是一个初始化为指向不可变int类对象ci的可变指针对象 const auto f = ci; // f是一个初始化值为0的不可变int对象 decltype不会去除顶层const。 const int ci = 0; decltype(ci) x = 0; // x的类型是const int ","date":"2021-10-26","objectID":"/posts/const/:1:0","tags":["C++"],"title":"重学C++：Const二三事","uri":"/posts/const/"},{"categories":["Programming Language"],"content":"必须要理解的点 const对象在创建时必须进行初始化。 常量引用即对const对象的引用。 常量引用绑定不可变对象和可变对象时含义不同。 可变对象 不可变对象 用常量引用绑定 可以 必须 常量引用的含义 不能通过此引用改变对象的值 不可以改变对象的值 常量引用绑定到可变对象上：对原有可操作性质的窄化，减少操作肯定不会引发错误，所以是允许的。 非常量引用绑定到不可变对象上：对原有可操作性质的拓宽，增加不允许的操作会出错、，所以不可变对象必须使用常量引用。 因为指针是对象，而引用不是对象，所以const和指针的组合有2种情况，const和引用的组合只有1种情况。 指针 指向常量的指针（pointer to const）：不能通过此指针修改对应的量。 常量指针（const pointer）：指针本身的值不可变，即不能用指针指向其他对象，这种不可重新绑定的特性类似于引用。 引用 常量引用：不能通过此引用修改对应的量。 顶层const表示指针本身是常量，推广之后可以指任意对象是常量； 底层const表示指针指向的对象是常量，推广之后主要于指针和引用等复合类型的基本类型部分有关。 常量表达式指：值不会改变，在编译过程中就能得到计算结果的表达式。 为什么需要constexpr？ 因为实际中很难判断一个初始值是否为常量表达式。 使用constexpr相当于把验证变量的值是否是一个常量表达式的工作交给了编译器。 用constexpr声明的变量一定是一个变量，并且必须用常量表达式来初始化。 ","date":"2021-10-26","objectID":"/posts/const/:2:0","tags":["C++"],"title":"重学C++：Const二三事","uri":"/posts/const/"},{"categories":["Programming Language"],"content":"建议 如果认定变量是一个常量表达式，那就将其声明成constexpr类型。 ","date":"2021-10-26","objectID":"/posts/const/:3:0","tags":["C++"],"title":"重学C++：Const二三事","uri":"/posts/const/"}]