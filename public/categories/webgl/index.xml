<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>WebGL - 分类 - Horel&#39;s Blog</title>
        <link>http://limbostray.github.io/categories/webgl/</link>
        <description>WebGL - 分类 - Horel&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1494255412@mail.dlut.edu.cn (Horel)</managingEditor>
            <webMaster>1494255412@mail.dlut.edu.cn (Horel)</webMaster><lastBuildDate>Thu, 03 Mar 2022 10:31:04 &#43;0800</lastBuildDate><atom:link href="http://limbostray.github.io/categories/webgl/" rel="self" type="application/rss+xml" /><item>
    <title>WebGL Basics</title>
    <link>http://limbostray.github.io/posts/webgl-basics/</link>
    <pubDate>Thu, 03 Mar 2022 10:31:04 &#43;0800</pubDate><author>1494255412@mail.dlut.edu.cn (Horel)</author><guid>http://limbostray.github.io/posts/webgl-basics/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://tva4.sinaimg.cn/large/008ieO5lly8gqbwu0fjchj31hc0u0drh.jpg" referrerpolicy="no-referrer">
            </div><h1 id="coordinate-system">Coordinate System</h1>
<p>There are x, y, z axes in WebGL, where the z axis signifies <strong>depth</strong>.
The coordinates in WebGL are restricted to (1, 1, 1) and (-1, -1, -1).
Positive value meaning:
z: near viewer.
x: near right.
y: near top.</p>
<p></p>
<h1 id="graphics-system">Graphics System</h1>
<h2 id="vertices">Vertices</h2>
<p>To draw a polygon, we need to mark the points on the plane and join them to form a desired polygon.
A <code>vertex</code> is a point which defines the conjunction of the edges of a 3D object.
Use <code>javascript</code> arrays to stores points&rsquo; coordinates like <code>[0.5, 0.5, 0.5]</code>.</p>
<h2 id="indices">Indices</h2>
<p>The numerical values which are used to identify the vertices is call <code>Indices</code>.</p>
<h2 id="arrays">Arrays</h2>
<p>There are no predefined methods in WebGL to render the vertices directly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="buffers">Buffers</h2>
<p>Buffers are the memory areas of WebGL that hold the data.
There are various buffers:</p>
<ul>
<li><code>drawing buffer</code></li>
<li><code>frame buffer</code></li>
<li><code>vertex buffer</code></li>
<li><code>index buffer</code></li>
</ul>
<p>The <code>vertex buffer</code> and <code>index buffer</code> are used to describe and process the geometry of the model, stores data about <code>vertices</code> and <code>indices</code> respectively.</p>
<p>The <code>frame buffer</code> is a portion of graphics memory that hold the scene data. This buffer contains details such as width and height of the surface (in pixels), color of each pixel, depth and stencil buffers.</p>
<h2 id="mesh">Mesh</h2>
<p>The WebGL API provides two methods to draw 2D or 3D objects:</p>
<ul>
<li><code>drawArrays()</code></li>
<li><code>drawElements()</code></li>
</ul>
<p>They accept a parameter called <code>mode</code> using which you can select the object you want to draw.</p>
<p><code>mode</code>: <code>points</code> or <code>lines</code> or <code>triangles</code></p>
<p>We can construct primitive polygons using points, lines and triangles.</p>
<p>Thereafter, we can form a <code>mesh</code> using these polygons.</p>
<p>A 3D object drawn using primitive polygons is called a <code>mesh</code>.</p>
<h2 id="shader-programs">Shader Programs</h2>
<p>Since WebGL uses GPU accelerated computing, the information about these triangles should be transferred from CPU to GPU which takes a lot of communication overhead.</p>
<p>WebGL provides a solution to reduce the communication overhead. Since it uses ES SL(Embedded System Shader Language) that runs on GPU, we write all the required programs to draw graphical elements on the client system using shader programs(OpenGL ES Shader Language).</p>
<p>Shader is a snippet that implements algorithms to get pixels for a mesh.</p>
<p>There are two types of shaders: <code>Vertex Shader</code> and <code>Fragment Shader</code>.</p>
<h3 id="vertex-shader">Vertex Shader</h3>
<ul>
<li>called on every vertex.</li>
<li>used to transform the geometry from one place to another.</li>
<li>handle the data of each vertex such as vertex coordinates, normals, colors, and texture coordinates.
<ul>
<li>vertex transformation</li>
<li>normal transformation and normalization</li>
<li>texture coordinate generation</li>
<li>texture coordinate transformation</li>
<li>lighting</li>
<li>color material application</li>
</ul>
</li>
</ul>
<h3 id="fragment-shaderpixel-shader">Fragment Shader(Pixel Shader)</h3>
<p>A mesh is formed by multiple triangles. The surface of each of the triangles is known as a fragment.</p>
<p><code>Fragment shader</code> is the code that runs on all pixels of every fragment.</p>
<p>It is written to calculate and fill the color on <em>individual pixels</em>.</p>
<ul>
<li>operations on interpolated values</li>
<li>texture access</li>
<li>texture application</li>
<li>fog</li>
<li>color sum</li>
</ul>
<p></p>
<h2 id="opengl-es-sl-variables">OpenGL ES SL Variables</h2>
<p>To handle the data in the shader programs, ES SL provides three types of variables.</p>
<ul>
<li>
<p>Attributes: hold the input values of the vertex shader program. Attributes point to the vertex buffer objects that contains per-vertex data.</p>
</li>
<li>
<p>Uniforms: hold the input data that is common for both vertex and fragment shaders, such as light position, texture coordinates and color.</p>
</li>
<li>
<p>Varyings: used to pass the data from the vertex shader to the fragment shader.</p>
</li>
</ul>
]]></description>
</item>
</channel>
</rss>
