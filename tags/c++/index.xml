<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43; - 标签 - Horel&#39;s Blog</title>
        <link>http://limbostray.github.io/tags/c&#43;&#43;/</link>
        <description>C&#43;&#43; - 标签 - Horel&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1494255412@mail.dlut.edu.cn (Horel)</managingEditor>
            <webMaster>1494255412@mail.dlut.edu.cn (Horel)</webMaster><lastBuildDate>Tue, 26 Oct 2021 21:14:32 &#43;0800</lastBuildDate><atom:link href="http://limbostray.github.io/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>重学C&#43;&#43;：类型推导</title>
    <link>http://limbostray.github.io/posts/auto/</link>
    <pubDate>Tue, 26 Oct 2021 21:14:32 &#43;0800</pubDate><author>1494255412@mail.dlut.edu.cn (Horel)</author><guid>http://limbostray.github.io/posts/auto/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>auto</code>可以在一条语句中声明多个变量，但是所有变量的类型必须一致。</p>
</li>
<li>
<p><code>decltype</code>在分析表达式类型时并不执行表达式。</p>
</li>
<li>
<p><code>decltype</code>处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。</p>
</li>
<li>
<p><code>decltype((variable))</code>的结果永远是引用。</p>
<p><code>decltype(variable)</code>的结果只有当<code>variable</code>是引用时才是引用。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li><code>auto</code>用于变量初始化时的类型推导，<code>decltype</code>用于分析表达式的类型。</li>
<li><code>auto</code>对引用类型推导时实际上用的是引用对象的值。</li>
<li><code>auto</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学C++：Const二三事</a>。</li>
<li><code>decltype</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学C++：Const二三事</a>。</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li><code>auto</code>尽量只在类型较长但比较清晰时使用。</li>
<li><code>decltype</code>尽量不要使用。</li>
</ol>
]]></description>
</item>
<item>
    <title>重学C&#43;&#43;：Const二三事</title>
    <link>http://limbostray.github.io/posts/const/</link>
    <pubDate>Tue, 26 Oct 2021 15:53:11 &#43;0800</pubDate><author>1494255412@mail.dlut.edu.cn (Horel)</author><guid>http://limbostray.github.io/posts/const/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p>仅用<code>const</code>修饰的对象只在单个文件中有效，如果想在多个文件之间共享<code>const</code>对象，必须在对象<strong>定义</strong>的前面加<code>extern</code>。</p>
</li>
<li>
<p>允许为一个常量引用绑定非常量的对象、字面量和表达式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>       <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>      <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r4</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>        <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r5</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">r5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                  <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">r1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>                 <span class="c1">// 错误
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>指向常量的指针和常量指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">err_numb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">cur_err</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">err_numb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">mut_pi_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="k">const</span> <span class="n">pi_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从声明语句的变量符号开始，自右向左看：</p>
<p><code>cur_err</code>首先是一个不可变对象，其次是一个指向<code>int</code>类型可变对象的指针。</p>
<p><code>mut_pi_pointer</code>首先是一个可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
<p><code>pi_pointer</code>首先是一个不可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
</li>
<li>
<p>当<code>typedef</code>遇到<code>const</code>时容易出现错误理解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">pstring</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>pstring</code>是<code>char *</code>的别名，即指向<code>char</code>的指针。</p>
<p><code>const</code>修饰的是<code>pstring</code>，因此<code>cstr</code>是：初始化值为<code>nullptr</code>的<strong>不可变指针</strong>。</p>
<p>错误理解会用<code>char *</code>替换掉<code>pstring</code>，即：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样从<code>cstr</code>开始自右向左读的话，<code>cstr</code>就会被理解成：指向<strong>字符常量</strong>的<strong>可变指针</strong>。</p>
</li>
<li>
<p><code>constexpr</code>属于顶层<code>const</code>，因此<code>constexpr</code>修饰指针意味着指针本身不可变。</p>
</li>
<li>
<p><code>auto</code>默认会去除顶层<code>const</code>，保留底层<code>const</code>，如果需要顶层<code>const</code>则需要显式加入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>       <span class="c1">// b是一个初始化值为0的可变int对象 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span>       <span class="c1">// c同b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>       <span class="c1">// d是一个初始化为指向可变int类对象i的可变指针对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>      <span class="c1">// e是一个初始化为指向不可变int类对象ci的可变指针对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// f是一个初始化值为0的不可变int对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>decltype</code>不会去除顶层<code>const</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// x的类型是const int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p><code>const</code>对象在创建时必须进行初始化。</p>
</li>
<li>
<p>常量引用即对<code>const</code>对象的引用。</p>
</li>
<li>
<p>常量引用绑定<em>不可变对象</em>和<em>可变对象</em>时含义不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">可变对象</th>
<th style="text-align:center">不可变对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用常量引用绑定</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">必须</td>
</tr>
<tr>
<td style="text-align:center">常量引用的含义</td>
<td style="text-align:center">不能通过此引用改变对象的值</td>
<td style="text-align:center">不可以改变对象的值</td>
</tr>
</tbody>
</table>
<p>常量引用绑定到可变对象上：对原有可操作性质的窄化，减少操作肯定不会引发错误，所以是允许的。</p>
<p>非常量引用绑定到不可变对象上：对原有可操作性质的拓宽，增加不允许的操作会出错、，所以不可变对象必须使用常量引用。</p>
</li>
<li>
<p>因为指针是对象，而引用不是对象，所以<code>const</code>和指针的组合有2种情况，<code>const</code>和引用的组合只有1种情况。</p>
<ul>
<li>指针
<ul>
<li>指向常量的指针（pointer to const）：不能通过此指针修改对应的量。</li>
<li>常量指针（const pointer）：指针本身的值不可变，即不能用指针指向其他对象，这种不可重新绑定的特性类似于引用。</li>
</ul>
</li>
<li>引用
<ul>
<li>常量引用：不能通过此引用修改对应的量。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>顶层<code>const</code>表示指针本身是常量，推广之后可以指任意对象是常量；</p>
<p>底层<code>const</code>表示指针指向的对象是常量，推广之后主要于指针和引用等复合类型的基本类型部分有关。</p>
</li>
<li>
<p><strong>常量表达式</strong>指：值不会改变，在编译过程中就能得到计算结果的表达式。</p>
</li>
<li>
<p>为什么需要<code>constexpr</code>？</p>
<p>因为实际中很难判断一个初始值是否为常量表达式。</p>
<p>使用<code>constexpr</code>相当于把验证变量的值是否是一个常量表达式的工作交给了编译器。</p>
<p>用<code>constexpr</code>声明的变量一定是一个变量，并且必须用常量表达式来初始化。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>如果认定变量是一个常量表达式，那就将其声明成<code>constexpr</code>类型。</li>
</ol>
]]></description>
</item>
</channel>
</rss>
